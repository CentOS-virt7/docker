From 7926826c140f63639ddadc1733458d8a31643384 Mon Sep 17 00:00:00 2001
From: Deng Guangxing <dengguangxing@huawei.com>
Date: Mon, 25 May 2015 09:16:17 +0200
Subject: [PATCH] 'docker rmi -f IMAGE_ID' untag all names and delete the image

If an image has been tagged to multiple repos and tags, 'docker
rmi -f IMAGE_ID' will just untag one random repo instead of
untagging all and deleting the image. This patch implement
this. This commit is composed of:

        *untag all names and delete the image

        *add test to this feature

        *modify commandline/cli.md to explain this

Signed-off-by: Deng Guangxing <dengguangxing@huawei.com>
---
 daemon/image_delete.go                    | 35 ++++++++++++++++++-----------
 docs/sources/reference/commandline/cli.md | 15 +++++++++++++
 integration-cli/docker_cli_rmi_test.go    | 37 +++++++++++++++++++++++++++++++
 3 files changed, 74 insertions(+), 13 deletions(-)

diff --git a/daemon/image_delete.go b/daemon/image_delete.go
index 0c0a534..7468595 100644
--- a/daemon/image_delete.go
+++ b/daemon/image_delete.go
@@ -35,6 +35,7 @@ func (daemon *Daemon) DeleteImage(eng *engine.Engine, name string, imgs *engine.
 		repoName, tag string
 		tags          = []string{}
 	)
+	repoAndTags := make(map[string][]string)
 
 	// FIXME: please respect DRY and centralize repo+tag parsing in a single central place! -- shykes
 	repoName, tag = parsers.ParseRepositoryTag(name)
@@ -73,19 +74,25 @@ func (daemon *Daemon) DeleteImage(eng *engine.Engine, name string, imgs *engine.
 			if repoName == "" || repoName == parsedRepo {
 				repoName = parsedRepo
 				if parsedTag != "" {
-					tags = append(tags, parsedTag)
+					repoAndTags[repoName] = append(repoAndTags[repoName], parsedTag)
 				}
 			} else if repoName != parsedRepo && !force && first {
 				// the id belongs to multiple repos, like base:latest and user:test,
 				// in that case return conflict
 				return fmt.Errorf("Conflict, cannot delete image %s because it is tagged in multiple repositories, use -f to force", name)
+			} else {
+				//the id belongs to multiple repos, with -f just delete all
+				repoName = parsedRepo
+				if parsedTag != "" {
+					repoAndTags[repoName] = append(repoAndTags[repoName], parsedTag)
+				}
 			}
 		}
 	} else {
-		tags = append(tags, tag)
+		repoAndTags[repoName] = append(repoAndTags[repoName], tag)
 	}
 
-	if !first && len(tags) > 0 {
+	if !first && len(repoAndTags) > 0 {
 		return nil
 	}
 
@@ -96,16 +103,18 @@ func (daemon *Daemon) DeleteImage(eng *engine.Engine, name string, imgs *engine.
 	}
 
 	// Untag the current image
-	for _, tag := range tags {
-		tagDeleted, err := daemon.Repositories().Delete(repoName, tag)
-		if err != nil {
-			return err
-		}
-		if tagDeleted {
-			out := &engine.Env{}
-			out.Set("Untagged", utils.ImageReference(repoName, tag))
-			imgs.Add(out)
-			eng.Job("log", "untag", img.ID, "").Run()
+	for repoName, tags := range repoAndTags {
+		for _, tag := range tags {
+			tagDeleted, err := daemon.Repositories().Delete(repoName, tag)
+			if err != nil {
+				return err
+			}
+			if tagDeleted {
+				out := &engine.Env{}
+				out.Set("Untagged", utils.ImageReference(repoName, tag))
+				imgs.Add(out)
+				eng.Job("log", "untag", img.ID, "").Run()
+			}
 		}
 	}
 	tags = daemon.Repositories().ByID()[img.ID]
diff --git a/docs/sources/reference/commandline/cli.md b/docs/sources/reference/commandline/cli.md
index 17ebcc9..5fdfd27 100644
--- a/docs/sources/reference/commandline/cli.md
+++ b/docs/sources/reference/commandline/cli.md
@@ -1703,6 +1703,21 @@ before the image is removed.
     Untagged: test:latest
     Deleted: fd484f19954f4920da7ff372b5067f5b7ddb2fd3830cecd17b96ea9e286ba5b8
 
+If you use the `-f` flag and specify the image's short or long ID, then this
+command untags and removes all images that match the specified ID.
+
+    $ docker images
+    REPOSITORY                TAG                 IMAGE ID            CREATED             SIZE
+    test1                     latest              fd484f19954f        23 seconds ago      7 B (virtual 4.964 MB)
+    test                      latest              fd484f19954f        23 seconds ago      7 B (virtual 4.964 MB)
+    test2                     latest              fd484f19954f        23 seconds ago      7 B (virtual 4.964 MB)
+
+    $ docker rmi -f fd484f19954f
+    Untagged: test1:latest
+    Untagged: test:latest
+    Untagged: test2:latest
+    Deleted: fd484f19954f4920da7ff372b5067f5b7ddb2fd3830cecd17b96ea9e286ba5b8
+
 An image pulled by digest has no tag associated with it:
 
     $ sudo docker images --digests
diff --git a/integration-cli/docker_cli_rmi_test.go b/integration-cli/docker_cli_rmi_test.go
index ffe15fc..3ce8779 100644
--- a/integration-cli/docker_cli_rmi_test.go
+++ b/integration-cli/docker_cli_rmi_test.go
@@ -95,6 +95,43 @@ func TestRmiTag(t *testing.T) {
 	logDone("rmi - tag,rmi- tagging the same images multiple times then removing tags")
 }
 
+func TestRmiImgIDForce(t *testing.T) {
+	runCmd := exec.Command(dockerBinary, "run", "-d", "busybox", "/bin/sh", "-c", "mkdir '/busybox-test'")
+	out, _, err := runCommandWithOutput(runCmd)
+	if err != nil {
+		t.Fatalf("failed to create a container:%s, %v", out, err)
+	}
+	containerID := strings.TrimSpace(out)
+	runCmd = exec.Command(dockerBinary, "commit", containerID, "busybox-test")
+	out, _, err = runCommandWithOutput(runCmd)
+	if err != nil {
+		t.Fatalf("failed to commit a new busybox-test:%s, %v", out, err)
+	}
+
+	imagesBefore, _, _ := dockerCmd(t, "images", "-a")
+	dockerCmd(t, "tag", "busybox-test", "utest:tag1")
+	dockerCmd(t, "tag", "busybox-test", "utest:tag2")
+	dockerCmd(t, "tag", "busybox-test", "utest/docker:tag3")
+	dockerCmd(t, "tag", "busybox-test", "utest:5000/docker:tag4")
+	{
+		imagesAfter, _, _ := dockerCmd(t, "images", "-a")
+		if strings.Count(imagesAfter, "\n") != strings.Count(imagesBefore, "\n")+4 {
+			t.Fatalf("tag busybox to create 4 more images with same imageID; docker images shows: %q\n", imagesAfter)
+		}
+	}
+	out, _, _ = dockerCmd(t, "inspect", "-f", "{{.Id}}", "busybox-test")
+	imgID := strings.TrimSpace(out)
+	dockerCmd(t, "rmi", "-f", imgID)
+	{
+		imagesAfter, _, _ := dockerCmd(t, "images", "-a")
+		if strings.Contains(imagesAfter, imgID[:12]) {
+			t.Fatalf("rmi -f %s failed, image still exists: %q\n\n", imgID, imagesAfter)
+		}
+
+	}
+	logDone("rmi - imgID,rmi -f imgID  delete all tagged repos of specific imgID")
+}
+
 func TestRmiTagWithExistingContainers(t *testing.T) {
 	defer deleteAllContainers()
 
-- 
2.1.0

