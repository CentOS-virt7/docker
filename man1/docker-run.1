.TH "DOCKER" "1" "APRIL 2014" "Docker User Manuals" ""
.SH NAME
.PP
docker\-run \- Run a process in an isolated container
.SH SYNOPSIS
.PP
\f[B]docker run\f[] [\f[B]\-a\f[]|\f[B]\-\-attach\f[][=]]
[\f[B]\-c\f[]|\f[B]\-\-cpu\-shares\f[][=0][\f[B]\-m\f[]|\f[B]\-\-memory\f[]=\f[I]memory\-limit\f[]]
[\f[B]\-\-cidfile\f[]=\f[I]file\f[]]
[\f[B]\-d\f[]|\f[B]\-\-detach\f[][=\f[I]false\f[]]]
[\f[B]\-\-dns\f[]=\f[I]IP\-address\f[]][\f[B]\-\-name\f[]=\f[I]name\f[]]
[\f[B]\-u\f[]|\f[B]\-\-user\f[]=\f[I]username\f[]|\f[I]uid\f[]][\f[B]\-\-link\f[]=\f[I]name\f[]:\f[I]alias\f[]]
[\f[B]\-e\f[]|\f[B]\-\-env\f[]=\f[I]environment\f[]]
[\f[B]\-\-entrypoint\f[]=\f[I]command\f[]]
[\f[B]\-\-expose\f[]=\f[I]port\f[]]
[\f[B]\-P\f[]|\f[B]\-\-publish\-all\f[][=\f[I]false\f[]]]
[\f[B]\-p\f[]|\f[B]\-\-publish\f[]=\f[I]port\-mappping\f[]]
[\f[B]\-h\f[]|\f[B]\-\-hostname\f[]=\f[I]hostname\f[]]
[\f[B]\-\-rm\f[][=\f[I]false\f[]]]
[\f[B]\-\-priviledged\f[][=\f[I]false\f[]]
[\f[B]\-i\f[]|\f[B]\-\-interactive\f[][=\f[I]false\f[]][\f[B]\-t\f[]|\f[B]\-\-tty\f[][=\f[I]false\f[]]]
[\f[B]\-\-lxc\-conf\f[]=\f[I]options\f[]][\f[B]\-n\f[]|\f[B]\-\-networking\f[][=\f[I]true\f[]]]
[\f[B]\-v\f[]|\f[B]\-\-volume\f[]=\f[I]volume\f[]]
[\f[B]\-\-volumes\-from\f[]=\f[I]container\-id\f[]]
[\f[B]\-w\f[]|\f[B]\-\-workdir\f[]=\f[I]directory\f[]]
[\f[B]\-\-sig\-proxy\f[][=\f[I]true\f[]]] IMAGE [COMMAND] [ARG...]
.SH DESCRIPTION
.PP
Run a process in a new container.
\f[B]docker run\f[] starts a process with its own file system, its own
networking, and its own isolated process tree.
The IMAGE which starts the process may define defaults related to the
process that will be run in the container, the networking to expose, and
more, but \f[B]docker run\f[] gives final control to the operator or
administrator who starts the container from the image.
For that reason \f[B]docker run\f[] has more options than any other
Docker command.
.PP
If the IMAGE is not already loaded then \f[B]docker run\f[] will pull
the IMAGE, and all image dependencies, from the repository in the same
way running \f[B]docker pull\f[] IMAGE, before it starts the container
from that image.
.SH OPTIONS
.PP
\f[B]\-a\f[],
\f[B]\-\-attach\f[]=\f[I]stdin\f[]|\f[I]stdout\f[]|\f[I]stderr\f[]
Attach to stdin, stdout or stderr.
In foreground mode (the default when \f[B]\-d\f[] is not specified),
\f[B]docker run\f[] can start the process in the container and attach
the console to the process's standard input, output, and standard error.
It can even pretend to be a TTY (this is what most commandline
executables expect) and pass along signals.
The \f[B]\-a\f[] option can be set for each of stdin, stdout, and
stderr.
.PP
\f[B]\-c\f[], \f[B]\-\-cpu\-shares\f[]=0 CPU shares in relative weight.
You can increase the priority of a container with the \-c option.
By default, all containers run at the same priority and get the same
proportion of CPU cycles, but you can tell the kernel to give more
shares of CPU time to one or more containers when you start them via
\f[B]docker run\f[].
.PP
\f[B]\-\-cidfile\f[]=\f[I]file\f[] Write the container ID to the file
specified.
.PP
\f[B]\-d\f[], \f[B]\-detach\f[]=\f[I]true\f[]|\f[I]false\f[] Detached
mode.
This runs the container in the background.
It outputs the new container\[aq]s ID and any error messages.
At any time you can run \f[B]docker ps\f[] in the other shell to view a
list of the running containers.
You can reattach to a detached container with \f[B]docker attach\f[].
If you choose to run a container in the detached mode, then you cannot
use the \f[B]\-rm\f[] option.
.PP
\f[B]\-\-dns\f[]=\f[I]IP\-address\f[] Set custom DNS servers.
This option can be used to override the DNS configuration passed to the
container.
Typically this is necessary when the host DNS configuration is invalid
for the container (eg.
127.0.0.1).
When this is the case the \f[B]\-dns\f[] flags is necessary for every
run.
.PP
\f[B]\-e\f[], \f[B]\-env\f[]=\f[I]environment\f[] Set environment
variables.
This option allows you to specify arbitrary environment variables that
are available for the process that will be launched inside of the
container.
.PP
\f[B]\-\-entrypoint\f[]=\f[I]command\f[] This option allows you to
overwrite the default entrypoint of the image that is set in the
Dockerfile.
The ENTRYPOINT of an image is similar to a COMMAND because it specifies
what executable to run when the container starts, but it is (purposely)
more difficult to override.
The ENTRYPOINT gives a container its default nature or behavior, so that
when you set an ENTRYPOINT you can run the container as if it were that
binary, complete with default options, and you can pass in more options
via the COMMAND.
But, sometimes an operator may want to run something else inside the
container, so you can override the default ENTRYPOINT at runtime by
using a \f[B]\-\-entrypoint\f[] and a string to specify the new
ENTRYPOINT.
.PP
\f[B]\-\-expose\f[]=\f[I]port\f[] Expose a port from the container
without publishing it to your host.
A containers port can be exposed to other containers in three ways: 1)
The developer can expose the port using the EXPOSE parameter of the
Dockerfile, 2) the operator can use the \f[B]\-\-expose\f[] option with
\f[B]docker run\f[], or 3) the container can be started with the
\f[B]\-\-link\f[].
.PP
\f[B]\-m\f[], \f[B]\-memory\f[]=\f[I]memory\-limit\f[] Allows you to
constrain the memory available to a container.
If the host supports swap memory, then the \-m memory setting can be
larger than physical RAM.
The memory limit format: , where unit = b, k, m or g.
.PP
\f[B]\-P\f[], \f[B]\-publish\-all\f[]=\f[I]true\f[]|\f[I]false\f[] When
set to true publish all exposed ports to the host interfaces.
The default is false.
If the operator uses \-P (or \-p) then Docker will make the exposed port
accessible on the host and the ports will be available to any client
that can reach the host.
To find the map between the host ports and the exposed ports, use
\f[B]docker port\f[].
.PP
\f[B]\-p\f[], \f[B]\-publish\f[]=[] Publish a container\[aq]s port to
the host (format: ip:hostPort:containerPort | ip::containerPort |
hostPort:containerPort) (use \f[B]docker port\f[] to see the actual
mapping)
.PP
\f[B]\-h\f[], \f[B]\-hostname\f[]=\f[I]hostname\f[] Sets the container
host name that is available inside the container.
.PP
\f[B]\-i\f[], \f[B]\-interactive\f[]=\f[I]true\f[]|\f[I]false\f[] When
set to true, keep stdin open even if not attached.
The default is false.
.PP
\f[B]\-\-link\f[]=\f[I]name\f[]:\f[I]alias\f[] Add link to another
container.
The format is name:alias.
If the operator uses \f[B]\-\-link\f[] when starting the new client
container, then the client container can access the exposed port via a
private networking interface.
Docker will set some environment variables in the client container to
help indicate which interface and port to use.
.PP
\f[B]\-n\f[], \f[B]\-networking\f[]=\f[I]true\f[]|\f[I]false\f[] By
default, all containers have networking enabled (true) and can make
outgoing connections.
The operator can disable networking with \f[B]\-\-networking\f[] to
false.
This disables all incoming and outgoing networking.
In cases like this , I/O can only be performed through files or by using
STDIN/STDOUT.
.PP
Also by default, the container will use the same DNS servers as the
host.
The operator may override this with \f[B]\-dns\f[].
.PP
\f[B]\-\-name\f[]=\f[I]name\f[] Assign a name to the container.
The operator can identify a container in three ways:
.IP
.nf
\f[C]
UUID\ long\ identifier\ (“f78375b1c487e03c9438c729345e54db9d20cfa2ac1fc3494b6eb60872e74778”)
UUID\ short\ identifier\ (“f78375b1c487”)
Name\ (“jonah”)
\f[]
.fi
.PP
The UUID identifiers come from the Docker daemon, and if a name is not
assigned to the container with \f[B]\-\-name\f[] then the daemon will
also generate a random string name.
The name is useful when defining links (see \f[B]\-\-link\f[]) (or any
other place you need to identify a container).
This works for both background and foreground Docker containers.
.PP
\f[B]\-\-privileged\f[]=\f[I]true\f[]|\f[I]false\f[] Give extended
privileges to this container.
By default, Docker containers are “unprivileged” (=false) and cannot,
for example, run a Docker daemon inside the Docker container.
This is because by default a container is not allowed to access any
devices.
A “privileged” container is given access to all devices.
.PP
When the operator executes \f[B]docker run \-privileged\f[], Docker will
enable access to all devices on the host as well as set some
configuration in AppArmor to allow the container nearly all the same
access to the host as processes running outside of a container on the
host.
.PP
\f[B]\-\-rm\f[]=\f[I]true\f[]|\f[I]false\f[] If set to \f[I]true\f[] the
container is automatically removed when it exits.
The default is \f[I]false\f[].
This option is incompatible with \f[B]\-d\f[].
.PP
\f[B]\-\-sig\-proxy\f[]=\f[I]true\f[]|\f[I]false\f[] When set to true,
proxify all received signals to the process (even in non\-tty mode).
The default is true.
.PP
\f[B]\-t\f[], \f[B]\-tty\f[]=\f[I]true\f[]|\f[I]false\f[] When set to
true Docker can allocate a pseudo\-tty and attach to the standard input
of any container.
This can be used, for example, to run a throwaway interactive shell.
The default is value is false.
.PP
\f[B]\-u\f[], \f[B]\-user\f[]=\f[I]username\f[],\f[I]uid\f[] Set a
username or UID for the container.
.PP
\f[B]\-v\f[], \f[B]\-volume\f[]=\f[I]volume\f[] Bind mount a volume to
the container.
The \f[B]\-v\f[] option can be used one or more times to add one or more
mounts to a container.
These mounts can then be used in other containers using the
\f[B]\-\-volumes\-from\f[] option.
See examples.
.PP
\f[B]\-\-volumes\-from\f[]=\f[I]container\-id\f[] Will mount volumes
from the specified container identified by container\-id.
Once a volume is mounted in a one container it can be shared with other
containers using the \f[B]\-\-volumes\-from\f[] option when running
those other containers.
The volumes can be shared even if the original container with the mount
is not running.
.PP
\f[B]\-w\f[], \f[B]\-workdir\f[]=\f[I]directory\f[] Working directory
inside the container.
The default working directory for running binaries within a container is
the root directory (/).
The developer can set a different default with the Dockerfile WORKDIR
instruction.
The operator can override the working directory by using the
\f[B]\-w\f[] option.
.PP
\f[B]IMAGE\f[] The image name or ID.
.PP
\f[B]COMMAND\f[] The command or program to run inside the image.
.PP
\f[B]ARG\f[] The arguments for the command to be run in the container.
.SH EXAMPLES
.SS Exposing log messages from the container to the host\[aq]s log
.PP
If you want messages that are logged in your container to show up in the
host\[aq]s syslog/journal then you should bind mount the /var/log
directory as follows.
.IP
.nf
\f[C]
#\ docker\ run\ \-v\ /dev/log:/dev/log\ \-i\ \-t\ fedora\ /bin/bash
\f[]
.fi
.PP
From inside the container you can test this by sending a message to the
log.
.IP
.nf
\f[C]
(bash)#\ logger\ "Hello\ from\ my\ container"
\f[]
.fi
.PP
Then exit and check the journal.
.IP
.nf
\f[C]
#\ exit

#\ journalctl\ \-b\ |\ grep\ Hello
\f[]
.fi
.PP
This should list the message sent to logger.
.SS Attaching to one or more from STDIN, STDOUT, STDERR
.PP
If you do not specify \-a then Docker will attach everything
(stdin,stdout,stderr) .
You can specify to which of the three standard streams (stdin, stdout,
stderr) you'd like to connect instead, as in:
.IP
.nf
\f[C]
#\ docker\ run\ \-a\ stdin\ \-a\ stdout\ \-i\ \-t\ fedora\ /bin/bash
\f[]
.fi
.SS Linking Containers
.PP
The link feature allows multiple containers to communicate with each
other.
For example, a container whose Dockerfile has exposed port 80 can be run
and named as follows:
.IP
.nf
\f[C]
#\ docker\ run\ \-\-name=link\-test\ \-d\ \-i\ \-t\ fedora/httpd
\f[]
.fi
.PP
A second container, in this case called linker, can communicate with the
httpd container, named link\-test, by running with the
\f[B]\-\-link=:\f[]
.IP
.nf
\f[C]
#\ docker\ run\ \-t\ \-i\ \-\-link=link\-test:lt\ \-\-name=linker\ fedora\ /bin/bash
\f[]
.fi
.PP
Now the container linker is linked to container link\-test with the
alias lt.
Running the \f[B]env\f[] command in the linker container shows
environment variables with the LT (alias) context (\f[B]LT_\f[])
.IP
.nf
\f[C]
#\ env
HOSTNAME=668231cb0978
TERM=xterm
LT_PORT_80_TCP=tcp://172.17.0.3:80
LT_PORT_80_TCP_PORT=80
LT_PORT_80_TCP_PROTO=tcp
LT_PORT=tcp://172.17.0.3:80
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
PWD=/
LT_NAME=/linker/lt
SHLVL=1
HOME=/
LT_PORT_80_TCP_ADDR=172.17.0.3
_=/usr/bin/env
\f[]
.fi
.PP
When linking two containers Docker will use the exposed ports of the
container to create a secure tunnel for the parent to access.
.SS Mapping Ports for External Usage
.PP
The exposed port of an application can be mapped to a host port using
the \f[B]\-p\f[] flag.
For example a httpd port 80 can be mapped to the host port 8080 using
the following:
.IP
.nf
\f[C]
#\ docker\ run\ \-p\ 8080:80\ \-d\ \-i\ \-t\ fedora/httpd
\f[]
.fi
.SS Creating and Mounting a Data Volume Container
.PP
Many applications require the sharing of persistent data across several
containers.
Docker allows you to create a Data Volume Container that other
containers can mount from.
For example, create a named container that contains directories
/var/volume1 and /tmp/volume2.
The image will need to contain these directories so a couple of RUN
mkdir instructions might be required for you fedora\-data image:
.IP
.nf
\f[C]
#\ docker\ run\ \-\-name=data\ \-v\ /var/volume1\ \-v\ /tmp/volume2\ \-i\ \-t\ fedora\-data\ true
#\ docker\ run\ \-\-volumes\-from=data\ \-\-name=fedora\-container1\ \-i\ \-t\ fedora\ bash
\f[]
.fi
.PP
Multiple \-volumes\-from parameters will bring together multiple data
volumes from multiple containers.
And it\[aq]s possible to mount the volumes that came from the DATA
container in yet another container via the fedora\-container1
intermidiery container, allowing to abstract the actual data source from
users of that data:
.IP
.nf
\f[C]
#\ docker\ run\ \-\-volumes\-from=fedora\-container1\ \-\-name=fedora\-container2\ \-i\ \-t\ fedora\ bash
\f[]
.fi
.SS Mounting External Volumes
.PP
To mount a host directory as a container volume, specify the absolute
path to the directory and the absolute path for the container directory
separated by a colon:
.IP
.nf
\f[C]
#\ docker\ run\ \-v\ /var/db:/data1\ \-i\ \-t\ fedora\ bash
\f[]
.fi
.PP
When using SELinux, be aware that the host has no knowledge of container
SELinux policy.
Therefore, in the above example, if SELinux policy is enforced, the
\f[C]/var/db\f[] directory is not writable to the container.
A "Permission Denied" message will occur and an avc: message in the
host\[aq]s syslog.
.PP
To work around this, at time of writing this man page, the following
command needs to be run in order for the proper SELinux policy type
label to be attached to the host directory:
.IP
.nf
\f[C]
#\ chcon\ \-Rt\ svirt_sandbox_file_t\ /var/db
\f[]
.fi
.PP
Now, writing to the /data1 volume in the container will be allowed and
the changes will also be reflected on the host in /var/db.
.SH HISTORY
.PP
April 2014, Originally compiled by William Henry (whenry at redhat dot
com) based on docker.io source material and internal work.
.SH AUTHORS
William Henry.
