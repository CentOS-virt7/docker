diff --git a/docker/docker.go b/docker/docker.go
index e906b20..696bd72 100644
--- a/docker/docker.go
+++ b/docker/docker.go
@@ -14,6 +14,7 @@ import (
 	"github.com/docker/docker/dockerversion"
 	flag "github.com/docker/docker/pkg/mflag"
 	"github.com/docker/docker/reexec"
+	"github.com/docker/docker/registry"
 	"github.com/docker/docker/utils"
 )
 
@@ -34,6 +35,15 @@ func main() {
 		showVersion()
 		return
 	}
+	if *flDefaultRegistry != "" {
+		registry.RegistryList = strings.Split(*flDefaultRegistry, ",")
+	}
+	if *flAppendRegistry != "" {
+		regs := strings.Split(*flAppendRegistry, ",")
+		for r := range regs {
+			registry.RegistryList = append(registry.RegistryList, regs[r])
+		}
+	}
 	if *flDebug {
 		os.Setenv("DEBUG", "1")
 	}
diff --git a/docs/man/docker.1.md b/docs/man/docker.1.md
index 4e88bff..33e0fde 100644
--- a/docs/man/docker.1.md
+++ b/docs/man/docker.1.md
@@ -76,6 +76,12 @@ unix://[/path/to/socket] to use.
 **-v**=*true*|*false*
   Print version information and quit. Default is false.
 
+**--registry-append**=""
+  Comma separated list of registries to append to default registry. Registries will be searched in reverse order.
+
+**--registry-replace**=""
+Comma separated list of registries to replace the default registry. Registries will be searched in reverse order
+
 **--selinux-enabled**=*true*|*false*
   Enable selinux support. Default is false. SELinux does not presently support the BTRFS storage driver.
 
diff --git a/graph/pull.go b/graph/pull.go
index 600e524..d171a06 100644
--- a/graph/pull.go
+++ b/graph/pull.go
@@ -15,6 +15,27 @@ import (
 	"github.com/docker/docker/utils"
 )
 
+func (s *TagStore) CmdRegistryPull(job *engine.Job) engine.Status {
+	var (
+		tmp    = job.Args[0]
+		status = engine.StatusErr
+	)
+	for r := len(registry.RegistryList) - 1; r >= 0; r-- {
+		if registry.RegistryList[r] != "index.docker.io" {
+			job.Args[0] = fmt.Sprintf("%s/%s", registry.RegistryList[r], tmp)
+		} else {
+			job.Args[0] = tmp
+		}
+		status := s.CmdPull(job)
+		if status == engine.StatusOK {
+			job.Args[1] = tmp
+			s.CmdTag(job)
+			return status
+		}
+	}
+	return status
+}
+
 func (s *TagStore) CmdPull(job *engine.Job) engine.Status {
 	if n := len(job.Args); n != 1 && n != 2 {
 		return job.Errorf("Usage: %s IMAGE [TAG]", job.Name)
diff --git a/graph/service.go b/graph/service.go
index e9ff872..38df7ac 100644
--- a/graph/service.go
+++ b/graph/service.go
@@ -23,7 +23,7 @@ func (s *TagStore) Install(eng *engine.Engine) error {
 		"viz":            s.CmdViz,
 		"load":           s.CmdLoad,
 		"import":         s.CmdImport,
-		"pull":           s.CmdPull,
+		"pull":           s.CmdRegistryPull,
 		"push":           s.CmdPush,
 	} {
 		if err := eng.Register(name, handler); err != nil {
diff --git a/registry/registry.go b/registry/registry.go
index 2b03c73..e13e68a 100644
--- a/registry/registry.go
+++ b/registry/registry.go
@@ -268,9 +268,6 @@ func ResolveRepositoryName(reposName string) (string, string, error) {
 	}
 	hostname := nameParts[0]
 	reposName = nameParts[1]
-	if strings.Contains(hostname, "index.docker.io") {
-		return "", "", fmt.Errorf("Invalid repository name, try \"%s\" instead", reposName)
-	}
 	if err := validateRepositoryName(reposName); err != nil {
 		return "", "", err
 	}
diff --git a/registry/service.go b/registry/service.go
index 0e6f1bd..b44ca7f 100644
--- a/registry/service.go
+++ b/registry/service.go
@@ -4,6 +4,8 @@ import (
 	"github.com/docker/docker/engine"
 )
 
+var RegistryList = []string{"index.docker.io"}
+
 // Service exposes registry capabilities in the standard Engine
 // interface. Once installed, it extends the engine with the
 // following calls:
@@ -35,6 +37,7 @@ func (s *Service) Auth(job *engine.Job) engine.Status {
 	var (
 		err        error
 		authConfig = &AuthConfig{}
+		status     string
 	)
 
 	job.GetenvJson("authConfig", authConfig)
@@ -46,7 +49,15 @@ func (s *Service) Auth(job *engine.Job) engine.Status {
 		}
 		authConfig.ServerAddress = addr
 	}
-	status, err := Login(authConfig, HTTPRequestFactory(nil))
+	for reg := len(RegistryList) - 1; reg >= 0; reg-- {
+		if endpoint, err := ExpandAndVerifyRegistryUrl(RegistryList[reg]); err == nil {
+			authConfig.ServerAddress = endpoint
+			status, err = Login(authConfig, HTTPRequestFactory(nil))
+			if err == nil {
+				break
+			}
+		}
+	}
 	if err != nil {
 		return job.Error(err)
 	}
